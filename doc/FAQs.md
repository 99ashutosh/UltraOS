## FAQs

#### GetTime

Problem This method directly uses the macro definition of read scr in the riscv library to read out the register corresponding to 0XC01. The code is:

```rust
llvm_asm!("csrrs $0, $1, x0" : "=r"(r) : "i"($csr_number) :: "volatile");
```

It selects the appropriate register by the compiler, reads the clock CSR and assigns it to the `usize variable r`. The final optimized instruction is

```rust
rdtime $0
```

The $0 here is determined by the compiler, so there is no problem on the surface. But in fact, the rd register of K210's CSR read and write instructions cannot be all registers, it only supports a0-a7 and s0-s6 as rd. In this case, we must select the corresponding register, but not by the compiler. So we change it to:

```rust
asm!(
​      "rdtime a0",
​      inout("a0") time
​    );
```

Read `time` as time.

#### BusyBox Running

##### Case 1

At address `0xf2e8`, `pc` jumps to `0`, and the start instruction is abnormal.

```asm
0xf2d8:      jalr    t1,t3
0xf2dc:      nop
0xf2e0:      auipc   t3,0xe8
0xf2e4:      ld      t3,2024(t3)
0xf2e8:      jalr    t1,t3
```

###### Findings

When the program runs to the end, no system calls are made. This strongly implies that there is a problem with the exec program.

Try to add parameters when exec busybox, the error address (`0xf2e8`) remains unchanged.

The data stored in the memory `2024` (`t3`) with the jump address is always `0`. This address is `f72e0+7e8=F7AC8`

###### Conclusion

A dynamic bin file is used, and it is guessed that it jumps to a dynamic library, so we use a static bin file.

##### Case 2

`0x105c4` jumps into address `0xcb5c4`, and then triggers a load page fault.

```
[kernel] Exception(LoadPageFault) in application, bad addr = 0x3c37b13cb9b7b08, bad instruction = 0xcb608, core dumped.
```

Enter the parameter `sh` when running busybox, triggering an exception in the same place, but the load address is different.

```
[kernel] Exception(LoadPageFault) in application, bad addr = 0x34397ffffffcfe8, bad instruction = 0xcb608, core dumped.
```

###### Conclusion

The `argv` argument to `exec` is passed incorrectly. The top of the userheap stack is `argv`, and the bottom of the stack is a sequence of strings (parameters), but our implementation is the opposite. It is wrong to place the parameters on the top of the stack, so we adjusted it.

##### Case 3

在此之前，调用了四种不同的id，使用了两次brk，共六次系统调用，程序运行已经很久，不再位于初始区域。在这个过程之中，tp为0，未被赋值过，但是被使用过。gp被使用过，也被赋值过。
>[kernel] Exception(StorePageFault) in application, bad addr = 0x0, bad instruction = 0x1326ae, core dumped.

###### 目前发现

Before that, four different ids were called, brk was used twice, and a total of six system calls were made. The program has been running for a long time and is no longer in the initial area. During this process, tp is 0, has not been assigned, but has been used. gp has been used and assigned.

```
[kernel] Exception(StorePageFault) in application, bad addr = 0x0, bad instruction = 0xc50e2, core dumped.
```

Access the address at 12 13D0, and then use its data as the address to store the value of s0, but the corresponding address is 0, resulting in an error. After the query, the address is located in the GOT section, which means that this is the address of the global variable.

###### Conclusion

We observed the GOT segment in the ELF file and found that the corresponding address data is not zero. Further, we use GDB to observe that when the entire program is running, the data in the GOT segment is zero, and the data in the DATA segment is also zero. The whole level is divided into two program areas, DATA and GOT are both located in the second program area, which strongly implies that there is a big problem in the establishment of the second program area, and its data has not been successfully copied.

##### Case 4

```
[kernel] Exception(LoadPageFault) in application, bad addr = 0x0, bad instruction = 0x10b70, core dumped.
10b60: 9c 60     ld a5, 0(s1)// s1= 0xffffffffffffcfe0  a5=0 sp=0xffffffffffffcf80
10b62: 17 14 11 00  auipc s0, 273
10b66: 13 04 e4 99  addi s0, s0, -1634
10b6a: 13 07 d0 02  addi a4, zero, 45
10b6e: 1c e0     sd a5, 0(s0)
10b70: 83 c6 07 00  lbu a3, 0(a5)  // a5=0  s0=0x121500 
```

At the same time, access to the bottom of the stack is encountered, and a page fault occurs.

###### Conclusion

There are some problems in the whole logic of exec, so we improved the implementation of exec and passed in more complete data to support the running of the program. For specific changes, see "system call support.md".

#### `lmbench_all` run

##### Case 1

The address 0x1 is accessed there, causing a page fault.

###### Findings

This address must be accessed, because the address is generated by the pc. At first, we thought that this address should have data. After checking the ELF file, we found that a section was set in the area corresponding to addr 0, but we finally confirmed that addr 0 should mean that the section should not be placed in the program segment, it is auxiliary information . According to the idea of ​​this **assumption**, we believe that this code should not be executed.

According to the disassembly and gdb debugging, we found that this is the initialization before libc enters the main program. Before the problem PC occurs, there are four functions, one of which is auxv_init, which means that it is likely to be auxv's problem. We further found that there was something wrong with the address of the program header specified by us. We found that it was our own calculation error, and there was no effect after correction. So, we are going to compare the initial stack executed by lmbench_all in debian.

So, I got inspiration from the report of the Huake kernel team, and used the gdb debugger installed in debian to compare the initial stack. After constant comparison and modification, we found that we did not specify the address of random bytes, which caused an error. Our exec has already implemented random bytes, so we only need to specify its address, and it has passed smoothly.

###### Conclusion

Auxv in exec lacks the attribute of random bytes address.

##### Case 2

The error Kernel too old is reported. Similarly, we locate the initialization before libc enters the main program, which does not belong to lmbench_all. We found that uname was called before, so we tried to modify the content of uname to solve this problem.

##### Case 3 (to be fixed)

The pc jumps to 0, and the last system call is fstat (already near the end). Further debugging found that ra is 0.

During this process, we found an unsupported instruction on qemu debugging, which is a 4bytes floating-point instruction (2bytes support), and we modified rustSBI to skip this instruction.

The pc jumps to 0 because the function table is modified, and it jumps to 0 when the function is called. Finally, the trace found that the return value of exec is argc, which makes the user program a0 1, so it jumps to 0x1 and takes it out. 0.

##### Case 4

After entering the normal process, lmbench is ready to enter the main stage after fork, but suddenly mmaps 128MB of space, and then dies halfway because of insufficient space.

During the debugging process, we excluded the heap from the coverage of CoW, and found that the child process of fork died before mmap was executed. The reason was that the memory access address 0x18 triggered a page fault. After verification, a 0 was taken out as the base address, and the address where 0 is located is the data segment, which is the lock address in the dynamic library (ELF symbol table analysis), so we believe that the lock value will not be used for memory access, it must be fetched The address of the data is crooked.

##### Case 5

The strace of lmbench under debian and UltraOS is quite different, and the execution flow is also very different. For the lat_syscall NULL test, UltraOS ran 20 ppids in 0.08s, and debian ran 1.8w ppids in 2.35. UltraOS has a gettime and get resource system call every time ppid, which is different from debian (pure ppid), which means that the time has to count two additional system calls, so it will be much slower.
